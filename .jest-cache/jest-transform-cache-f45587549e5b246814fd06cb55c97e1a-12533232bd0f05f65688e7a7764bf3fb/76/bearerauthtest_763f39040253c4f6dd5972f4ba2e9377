6361b697ca48f70449d944655e632b90
/**
 * Tests for Bearer Token Authentication
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _bearerauth = require("./bearer-auth");
const _apikeys = require("./api-keys");
describe('Bearer Token Authentication', ()=>{
    describe('extractBearerToken', ()=>{
        it('should extract bearer token from Authorization header', ()=>{
            const token = (0, _bearerauth.extractBearerToken)('Bearer gcrm_abc123');
            expect(token).toBe('gcrm_abc123');
        });
        it('should return null for missing Authorization header', ()=>{
            const token = (0, _bearerauth.extractBearerToken)(undefined);
            expect(token).toBeNull();
        });
        it('should return null for invalid Authorization header format', ()=>{
            const token = (0, _bearerauth.extractBearerToken)('Basic abc123');
            expect(token).toBeNull();
        });
        it('should return null for header without Bearer prefix', ()=>{
            const token = (0, _bearerauth.extractBearerToken)('gcrm_abc123');
            expect(token).toBeNull();
        });
    });
    describe('API Key Generation and Hashing', ()=>{
        it('should generate unique API keys', ()=>{
            const key1 = (0, _apikeys.generateApiKey)();
            const key2 = (0, _apikeys.generateApiKey)();
            expect(key1).not.toBe(key2);
        });
        it('should generate keys with correct prefix', ()=>{
            const key = (0, _apikeys.generateApiKey)();
            expect(key).toMatch(/^gcrm_/);
        });
        it('should hash API keys consistently', ()=>{
            const key = 'gcrm_test123';
            const hash1 = (0, _apikeys.hashApiKey)(key);
            const hash2 = (0, _apikeys.hashApiKey)(key);
            expect(hash1).toBe(hash2);
        });
        it('should generate different hashes for different keys', ()=>{
            const key1 = (0, _apikeys.generateApiKey)();
            const key2 = (0, _apikeys.generateApiKey)();
            const hash1 = (0, _apikeys.hashApiKey)(key1);
            const hash2 = (0, _apikeys.hashApiKey)(key2);
            expect(hash1).not.toBe(hash2);
        });
        it('should hash to 64 character hex string (SHA256)', ()=>{
            const key = (0, _apikeys.generateApiKey)();
            const hash = (0, _apikeys.hashApiKey)(key);
            expect(hash).toMatch(/^[a-f0-9]{64}$/);
        });
    });
});
describe('API Key Management Routes', ()=>{
    describe('GET /api/api-keys', ()=>{
        it('should require authentication', async ()=>{
        // Test should verify 401 response without valid session/bearer token
        });
        it("should return only user's own API keys", async ()=>{
        // Test should verify that users only see their own keys
        });
        it('should not include key_hash in response', async ()=>{
        // Test should verify sensitive data is not exposed
        });
    });
    describe('POST /api/api-keys', ()=>{
        it('should create a new API key for authenticated user', async ()=>{
        // Test should create key and verify it returns plain key once
        });
        it('should require a name parameter', async ()=>{
        // Test should return 400 for missing name
        });
        it('should not return plain key in subsequent requests', async ()=>{
        // Test should verify key is only shown once at creation
        });
        it('should hash the key before storing', async ()=>{
        // Test should verify key_hash is stored, not plain key
        });
    });
    describe('DELETE /api/api-keys/[id]', ()=>{
        it("should delete only user's own API keys", async ()=>{
        // Test should verify 403 error when trying to delete others' keys
        });
        it('should return 404 for non-existent keys', async ()=>{
        // Test should verify proper error handling
        });
        it('should prevent authenticated access with deleted key', async ()=>{
        // Test should verify deleted key no longer works
        });
    });
});
describe('Bearer Token Usage Examples', ()=>{
    it('should accept bearer token in Authorization header', async ()=>{
    // Example: GET /api/songs/[id]
    // Headers: { Authorization: 'Bearer gcrm_examplekey123' }
    // Expected: 200 with song data
    });
    it('should reject requests with invalid bearer token', async ()=>{
    // Example: GET /api/songs/[id]
    // Headers: { Authorization: 'Bearer invalid_key' }
    // Expected: 401 Unauthorized
    });
    it('should accept session cookies as alternative auth', async ()=>{
    // Example: GET /api/songs/[id]
    // Cookies: [valid session cookie]
    // Expected: 200 with song data
    });
    it('should prioritize bearer token over session cookie', async ()=>{
    // Example: GET /api/songs/[id]
    // Headers: { Authorization: 'Bearer gcrm_examplekey123' }
    // Cookies: [valid session cookie]
    // Expected: Authenticates with bearer token
    });
});
describe('Security Considerations', ()=>{
    it('API keys should never be logged in plain text', ()=>{
    // Ensure no console.log or error messages expose keys
    });
    it('API key hashes should use strong hashing algorithm', ()=>{
    // Verify SHA256 is used, not weaker algorithms
    });
    it('RLS policies should restrict API key access', ()=>{
    // Users should only see/delete their own keys
    });
    it('last_used_at should be updated on successful auth', ()=>{
    // Helps users identify active vs unused keys
    });
    it('deleted keys should not grant access', ()=>{
    // Verify immediate revocation
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3Bpb3RyL0Rlc2t0b3AvZ3VpdGFyLWNybS9saWIvYmVhcmVyLWF1dGgudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRlc3RzIGZvciBCZWFyZXIgVG9rZW4gQXV0aGVudGljYXRpb25cbiAqL1xuXG5pbXBvcnQgeyBleHRyYWN0QmVhcmVyVG9rZW4gfSBmcm9tICdAL2xpYi9iZWFyZXItYXV0aCc7XG5pbXBvcnQgeyBnZW5lcmF0ZUFwaUtleSwgaGFzaEFwaUtleSB9IGZyb20gJ0AvbGliL2FwaS1rZXlzJztcblxuZGVzY3JpYmUoJ0JlYXJlciBUb2tlbiBBdXRoZW50aWNhdGlvbicsICgpID0+IHtcbiAgZGVzY3JpYmUoJ2V4dHJhY3RCZWFyZXJUb2tlbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGV4dHJhY3QgYmVhcmVyIHRva2VuIGZyb20gQXV0aG9yaXphdGlvbiBoZWFkZXInLCAoKSA9PiB7XG4gICAgICBjb25zdCB0b2tlbiA9IGV4dHJhY3RCZWFyZXJUb2tlbignQmVhcmVyIGdjcm1fYWJjMTIzJyk7XG4gICAgICBleHBlY3QodG9rZW4pLnRvQmUoJ2djcm1fYWJjMTIzJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBudWxsIGZvciBtaXNzaW5nIEF1dGhvcml6YXRpb24gaGVhZGVyJywgKCkgPT4ge1xuICAgICAgY29uc3QgdG9rZW4gPSBleHRyYWN0QmVhcmVyVG9rZW4odW5kZWZpbmVkKTtcbiAgICAgIGV4cGVjdCh0b2tlbikudG9CZU51bGwoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIG51bGwgZm9yIGludmFsaWQgQXV0aG9yaXphdGlvbiBoZWFkZXIgZm9ybWF0JywgKCkgPT4ge1xuICAgICAgY29uc3QgdG9rZW4gPSBleHRyYWN0QmVhcmVyVG9rZW4oJ0Jhc2ljIGFiYzEyMycpO1xuICAgICAgZXhwZWN0KHRva2VuKS50b0JlTnVsbCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gbnVsbCBmb3IgaGVhZGVyIHdpdGhvdXQgQmVhcmVyIHByZWZpeCcsICgpID0+IHtcbiAgICAgIGNvbnN0IHRva2VuID0gZXh0cmFjdEJlYXJlclRva2VuKCdnY3JtX2FiYzEyMycpO1xuICAgICAgZXhwZWN0KHRva2VuKS50b0JlTnVsbCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQVBJIEtleSBHZW5lcmF0aW9uIGFuZCBIYXNoaW5nJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgZ2VuZXJhdGUgdW5pcXVlIEFQSSBrZXlzJywgKCkgPT4ge1xuICAgICAgY29uc3Qga2V5MSA9IGdlbmVyYXRlQXBpS2V5KCk7XG4gICAgICBjb25zdCBrZXkyID0gZ2VuZXJhdGVBcGlLZXkoKTtcbiAgICAgIGV4cGVjdChrZXkxKS5ub3QudG9CZShrZXkyKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZ2VuZXJhdGUga2V5cyB3aXRoIGNvcnJlY3QgcHJlZml4JywgKCkgPT4ge1xuICAgICAgY29uc3Qga2V5ID0gZ2VuZXJhdGVBcGlLZXkoKTtcbiAgICAgIGV4cGVjdChrZXkpLnRvTWF0Y2goL15nY3JtXy8pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYXNoIEFQSSBrZXlzIGNvbnNpc3RlbnRseScsICgpID0+IHtcbiAgICAgIGNvbnN0IGtleSA9ICdnY3JtX3Rlc3QxMjMnO1xuICAgICAgY29uc3QgaGFzaDEgPSBoYXNoQXBpS2V5KGtleSk7XG4gICAgICBjb25zdCBoYXNoMiA9IGhhc2hBcGlLZXkoa2V5KTtcbiAgICAgIGV4cGVjdChoYXNoMSkudG9CZShoYXNoMik7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGdlbmVyYXRlIGRpZmZlcmVudCBoYXNoZXMgZm9yIGRpZmZlcmVudCBrZXlzJywgKCkgPT4ge1xuICAgICAgY29uc3Qga2V5MSA9IGdlbmVyYXRlQXBpS2V5KCk7XG4gICAgICBjb25zdCBrZXkyID0gZ2VuZXJhdGVBcGlLZXkoKTtcbiAgICAgIGNvbnN0IGhhc2gxID0gaGFzaEFwaUtleShrZXkxKTtcbiAgICAgIGNvbnN0IGhhc2gyID0gaGFzaEFwaUtleShrZXkyKTtcbiAgICAgIGV4cGVjdChoYXNoMSkubm90LnRvQmUoaGFzaDIpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYXNoIHRvIDY0IGNoYXJhY3RlciBoZXggc3RyaW5nIChTSEEyNTYpJywgKCkgPT4ge1xuICAgICAgY29uc3Qga2V5ID0gZ2VuZXJhdGVBcGlLZXkoKTtcbiAgICAgIGNvbnN0IGhhc2ggPSBoYXNoQXBpS2V5KGtleSk7XG4gICAgICBleHBlY3QoaGFzaCkudG9NYXRjaCgvXlthLWYwLTldezY0fSQvKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcblxuZGVzY3JpYmUoJ0FQSSBLZXkgTWFuYWdlbWVudCBSb3V0ZXMnLCAoKSA9PiB7XG4gIGRlc2NyaWJlKCdHRVQgL2FwaS9hcGkta2V5cycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJlcXVpcmUgYXV0aGVudGljYXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBUZXN0IHNob3VsZCB2ZXJpZnkgNDAxIHJlc3BvbnNlIHdpdGhvdXQgdmFsaWQgc2Vzc2lvbi9iZWFyZXIgdG9rZW5cbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIHJldHVybiBvbmx5IHVzZXIncyBvd24gQVBJIGtleXNcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gVGVzdCBzaG91bGQgdmVyaWZ5IHRoYXQgdXNlcnMgb25seSBzZWUgdGhlaXIgb3duIGtleXNcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgbm90IGluY2x1ZGUga2V5X2hhc2ggaW4gcmVzcG9uc2UnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBUZXN0IHNob3VsZCB2ZXJpZnkgc2Vuc2l0aXZlIGRhdGEgaXMgbm90IGV4cG9zZWRcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1BPU1QgL2FwaS9hcGkta2V5cycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGNyZWF0ZSBhIG5ldyBBUEkga2V5IGZvciBhdXRoZW50aWNhdGVkIHVzZXInLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBUZXN0IHNob3VsZCBjcmVhdGUga2V5IGFuZCB2ZXJpZnkgaXQgcmV0dXJucyBwbGFpbiBrZXkgb25jZVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXF1aXJlIGEgbmFtZSBwYXJhbWV0ZXInLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBUZXN0IHNob3VsZCByZXR1cm4gNDAwIGZvciBtaXNzaW5nIG5hbWVcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgbm90IHJldHVybiBwbGFpbiBrZXkgaW4gc3Vic2VxdWVudCByZXF1ZXN0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIFRlc3Qgc2hvdWxkIHZlcmlmeSBrZXkgaXMgb25seSBzaG93biBvbmNlIGF0IGNyZWF0aW9uXG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhc2ggdGhlIGtleSBiZWZvcmUgc3RvcmluZycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIFRlc3Qgc2hvdWxkIHZlcmlmeSBrZXlfaGFzaCBpcyBzdG9yZWQsIG5vdCBwbGFpbiBrZXlcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0RFTEVURSAvYXBpL2FwaS1rZXlzL1tpZF0nLCAoKSA9PiB7XG4gICAgaXQoXCJzaG91bGQgZGVsZXRlIG9ubHkgdXNlcidzIG93biBBUEkga2V5c1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBUZXN0IHNob3VsZCB2ZXJpZnkgNDAzIGVycm9yIHdoZW4gdHJ5aW5nIHRvIGRlbGV0ZSBvdGhlcnMnIGtleXNcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIDQwNCBmb3Igbm9uLWV4aXN0ZW50IGtleXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBUZXN0IHNob3VsZCB2ZXJpZnkgcHJvcGVyIGVycm9yIGhhbmRsaW5nXG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHByZXZlbnQgYXV0aGVudGljYXRlZCBhY2Nlc3Mgd2l0aCBkZWxldGVkIGtleScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIFRlc3Qgc2hvdWxkIHZlcmlmeSBkZWxldGVkIGtleSBubyBsb25nZXIgd29ya3NcbiAgICB9KTtcbiAgfSk7XG59KTtcblxuZGVzY3JpYmUoJ0JlYXJlciBUb2tlbiBVc2FnZSBFeGFtcGxlcycsICgpID0+IHtcbiAgaXQoJ3Nob3VsZCBhY2NlcHQgYmVhcmVyIHRva2VuIGluIEF1dGhvcml6YXRpb24gaGVhZGVyJywgYXN5bmMgKCkgPT4ge1xuICAgIC8vIEV4YW1wbGU6IEdFVCAvYXBpL3NvbmdzL1tpZF1cbiAgICAvLyBIZWFkZXJzOiB7IEF1dGhvcml6YXRpb246ICdCZWFyZXIgZ2NybV9leGFtcGxla2V5MTIzJyB9XG4gICAgLy8gRXhwZWN0ZWQ6IDIwMCB3aXRoIHNvbmcgZGF0YVxuICB9KTtcblxuICBpdCgnc2hvdWxkIHJlamVjdCByZXF1ZXN0cyB3aXRoIGludmFsaWQgYmVhcmVyIHRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgIC8vIEV4YW1wbGU6IEdFVCAvYXBpL3NvbmdzL1tpZF1cbiAgICAvLyBIZWFkZXJzOiB7IEF1dGhvcml6YXRpb246ICdCZWFyZXIgaW52YWxpZF9rZXknIH1cbiAgICAvLyBFeHBlY3RlZDogNDAxIFVuYXV0aG9yaXplZFxuICB9KTtcblxuICBpdCgnc2hvdWxkIGFjY2VwdCBzZXNzaW9uIGNvb2tpZXMgYXMgYWx0ZXJuYXRpdmUgYXV0aCcsIGFzeW5jICgpID0+IHtcbiAgICAvLyBFeGFtcGxlOiBHRVQgL2FwaS9zb25ncy9baWRdXG4gICAgLy8gQ29va2llczogW3ZhbGlkIHNlc3Npb24gY29va2llXVxuICAgIC8vIEV4cGVjdGVkOiAyMDAgd2l0aCBzb25nIGRhdGFcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBwcmlvcml0aXplIGJlYXJlciB0b2tlbiBvdmVyIHNlc3Npb24gY29va2llJywgYXN5bmMgKCkgPT4ge1xuICAgIC8vIEV4YW1wbGU6IEdFVCAvYXBpL3NvbmdzL1tpZF1cbiAgICAvLyBIZWFkZXJzOiB7IEF1dGhvcml6YXRpb246ICdCZWFyZXIgZ2NybV9leGFtcGxla2V5MTIzJyB9XG4gICAgLy8gQ29va2llczogW3ZhbGlkIHNlc3Npb24gY29va2llXVxuICAgIC8vIEV4cGVjdGVkOiBBdXRoZW50aWNhdGVzIHdpdGggYmVhcmVyIHRva2VuXG4gIH0pO1xufSk7XG5cbmRlc2NyaWJlKCdTZWN1cml0eSBDb25zaWRlcmF0aW9ucycsICgpID0+IHtcbiAgaXQoJ0FQSSBrZXlzIHNob3VsZCBuZXZlciBiZSBsb2dnZWQgaW4gcGxhaW4gdGV4dCcsICgpID0+IHtcbiAgICAvLyBFbnN1cmUgbm8gY29uc29sZS5sb2cgb3IgZXJyb3IgbWVzc2FnZXMgZXhwb3NlIGtleXNcbiAgfSk7XG5cbiAgaXQoJ0FQSSBrZXkgaGFzaGVzIHNob3VsZCB1c2Ugc3Ryb25nIGhhc2hpbmcgYWxnb3JpdGhtJywgKCkgPT4ge1xuICAgIC8vIFZlcmlmeSBTSEEyNTYgaXMgdXNlZCwgbm90IHdlYWtlciBhbGdvcml0aG1zXG4gIH0pO1xuXG4gIGl0KCdSTFMgcG9saWNpZXMgc2hvdWxkIHJlc3RyaWN0IEFQSSBrZXkgYWNjZXNzJywgKCkgPT4ge1xuICAgIC8vIFVzZXJzIHNob3VsZCBvbmx5IHNlZS9kZWxldGUgdGhlaXIgb3duIGtleXNcbiAgfSk7XG5cbiAgaXQoJ2xhc3RfdXNlZF9hdCBzaG91bGQgYmUgdXBkYXRlZCBvbiBzdWNjZXNzZnVsIGF1dGgnLCAoKSA9PiB7XG4gICAgLy8gSGVscHMgdXNlcnMgaWRlbnRpZnkgYWN0aXZlIHZzIHVudXNlZCBrZXlzXG4gIH0pO1xuXG4gIGl0KCdkZWxldGVkIGtleXMgc2hvdWxkIG5vdCBncmFudCBhY2Nlc3MnLCAoKSA9PiB7XG4gICAgLy8gVmVyaWZ5IGltbWVkaWF0ZSByZXZvY2F0aW9uXG4gIH0pO1xufSk7XG4iXSwibmFtZXMiOlsiZGVzY3JpYmUiLCJpdCIsInRva2VuIiwiZXh0cmFjdEJlYXJlclRva2VuIiwiZXhwZWN0IiwidG9CZSIsInVuZGVmaW5lZCIsInRvQmVOdWxsIiwia2V5MSIsImdlbmVyYXRlQXBpS2V5Iiwia2V5MiIsIm5vdCIsImtleSIsInRvTWF0Y2giLCJoYXNoMSIsImhhc2hBcGlLZXkiLCJoYXNoMiIsImhhc2giXSwibWFwcGluZ3MiOiJBQUFBOztDQUVDOzs7OzRCQUVrQzt5QkFDUTtBQUUzQ0EsU0FBUywrQkFBK0I7SUFDdENBLFNBQVMsc0JBQXNCO1FBQzdCQyxHQUFHLHlEQUF5RDtZQUMxRCxNQUFNQyxRQUFRQyxJQUFBQSw4QkFBa0IsRUFBQztZQUNqQ0MsT0FBT0YsT0FBT0csSUFBSSxDQUFDO1FBQ3JCO1FBRUFKLEdBQUcsdURBQXVEO1lBQ3hELE1BQU1DLFFBQVFDLElBQUFBLDhCQUFrQixFQUFDRztZQUNqQ0YsT0FBT0YsT0FBT0ssUUFBUTtRQUN4QjtRQUVBTixHQUFHLDhEQUE4RDtZQUMvRCxNQUFNQyxRQUFRQyxJQUFBQSw4QkFBa0IsRUFBQztZQUNqQ0MsT0FBT0YsT0FBT0ssUUFBUTtRQUN4QjtRQUVBTixHQUFHLHVEQUF1RDtZQUN4RCxNQUFNQyxRQUFRQyxJQUFBQSw4QkFBa0IsRUFBQztZQUNqQ0MsT0FBT0YsT0FBT0ssUUFBUTtRQUN4QjtJQUNGO0lBRUFQLFNBQVMsa0NBQWtDO1FBQ3pDQyxHQUFHLG1DQUFtQztZQUNwQyxNQUFNTyxPQUFPQyxJQUFBQSx1QkFBYztZQUMzQixNQUFNQyxPQUFPRCxJQUFBQSx1QkFBYztZQUMzQkwsT0FBT0ksTUFBTUcsR0FBRyxDQUFDTixJQUFJLENBQUNLO1FBQ3hCO1FBRUFULEdBQUcsNENBQTRDO1lBQzdDLE1BQU1XLE1BQU1ILElBQUFBLHVCQUFjO1lBQzFCTCxPQUFPUSxLQUFLQyxPQUFPLENBQUM7UUFDdEI7UUFFQVosR0FBRyxxQ0FBcUM7WUFDdEMsTUFBTVcsTUFBTTtZQUNaLE1BQU1FLFFBQVFDLElBQUFBLG1CQUFVLEVBQUNIO1lBQ3pCLE1BQU1JLFFBQVFELElBQUFBLG1CQUFVLEVBQUNIO1lBQ3pCUixPQUFPVSxPQUFPVCxJQUFJLENBQUNXO1FBQ3JCO1FBRUFmLEdBQUcsdURBQXVEO1lBQ3hELE1BQU1PLE9BQU9DLElBQUFBLHVCQUFjO1lBQzNCLE1BQU1DLE9BQU9ELElBQUFBLHVCQUFjO1lBQzNCLE1BQU1LLFFBQVFDLElBQUFBLG1CQUFVLEVBQUNQO1lBQ3pCLE1BQU1RLFFBQVFELElBQUFBLG1CQUFVLEVBQUNMO1lBQ3pCTixPQUFPVSxPQUFPSCxHQUFHLENBQUNOLElBQUksQ0FBQ1c7UUFDekI7UUFFQWYsR0FBRyxtREFBbUQ7WUFDcEQsTUFBTVcsTUFBTUgsSUFBQUEsdUJBQWM7WUFDMUIsTUFBTVEsT0FBT0YsSUFBQUEsbUJBQVUsRUFBQ0g7WUFDeEJSLE9BQU9hLE1BQU1KLE9BQU8sQ0FBQztRQUN2QjtJQUNGO0FBQ0Y7QUFFQWIsU0FBUyw2QkFBNkI7SUFDcENBLFNBQVMscUJBQXFCO1FBQzVCQyxHQUFHLGlDQUFpQztRQUNsQyxxRUFBcUU7UUFDdkU7UUFFQUEsR0FBRywwQ0FBMEM7UUFDM0Msd0RBQXdEO1FBQzFEO1FBRUFBLEdBQUcsMkNBQTJDO1FBQzVDLG1EQUFtRDtRQUNyRDtJQUNGO0lBRUFELFNBQVMsc0JBQXNCO1FBQzdCQyxHQUFHLHNEQUFzRDtRQUN2RCw4REFBOEQ7UUFDaEU7UUFFQUEsR0FBRyxtQ0FBbUM7UUFDcEMsMENBQTBDO1FBQzVDO1FBRUFBLEdBQUcsc0RBQXNEO1FBQ3ZELHdEQUF3RDtRQUMxRDtRQUVBQSxHQUFHLHNDQUFzQztRQUN2Qyx1REFBdUQ7UUFDekQ7SUFDRjtJQUVBRCxTQUFTLDZCQUE2QjtRQUNwQ0MsR0FBRywwQ0FBMEM7UUFDM0Msa0VBQWtFO1FBQ3BFO1FBRUFBLEdBQUcsMkNBQTJDO1FBQzVDLDJDQUEyQztRQUM3QztRQUVBQSxHQUFHLHdEQUF3RDtRQUN6RCxpREFBaUQ7UUFDbkQ7SUFDRjtBQUNGO0FBRUFELFNBQVMsK0JBQStCO0lBQ3RDQyxHQUFHLHNEQUFzRDtJQUN2RCwrQkFBK0I7SUFDL0IsMERBQTBEO0lBQzFELCtCQUErQjtJQUNqQztJQUVBQSxHQUFHLG9EQUFvRDtJQUNyRCwrQkFBK0I7SUFDL0IsbURBQW1EO0lBQ25ELDZCQUE2QjtJQUMvQjtJQUVBQSxHQUFHLHFEQUFxRDtJQUN0RCwrQkFBK0I7SUFDL0Isa0NBQWtDO0lBQ2xDLCtCQUErQjtJQUNqQztJQUVBQSxHQUFHLHNEQUFzRDtJQUN2RCwrQkFBK0I7SUFDL0IsMERBQTBEO0lBQzFELGtDQUFrQztJQUNsQyw0Q0FBNEM7SUFDOUM7QUFDRjtBQUVBRCxTQUFTLDJCQUEyQjtJQUNsQ0MsR0FBRyxpREFBaUQ7SUFDbEQsc0RBQXNEO0lBQ3hEO0lBRUFBLEdBQUcsc0RBQXNEO0lBQ3ZELCtDQUErQztJQUNqRDtJQUVBQSxHQUFHLCtDQUErQztJQUNoRCw4Q0FBOEM7SUFDaEQ7SUFFQUEsR0FBRyxxREFBcUQ7SUFDdEQsNkNBQTZDO0lBQy9DO0lBRUFBLEdBQUcsd0NBQXdDO0lBQ3pDLDhCQUE4QjtJQUNoQztBQUNGIn0=